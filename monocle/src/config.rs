use serde::{Deserialize, Serialize};
use shared::bad_pixel_map::BadPixelMap;
use shared::image_proc::detection::aabb::AABB;

/// Criteria for filtering candidate guide stars during acquisition.
///
/// These parameters control which detected stars are considered suitable for
/// tracking. Stars must pass all filters to be selected as guide stars. The
/// filters reject saturated stars, elongated objects (cosmic rays, galaxies),
/// stars too close to edges or bad pixels, and stars with insufficient SNR.
///
/// # Example Configuration
/// ```text
/// GuideStarFilters {
///     detection_threshold_sigma: 5.0,  // 5-sigma detection
///     snr_min: 10.0,                    // Minimum SNR of 10
///     diameter_range: (2.0, 20.0),      // 2-20 pixel diameter
///     aspect_ratio_max: 2.5,            // Reject elongated objects
///     saturation_value: 62000.0,        // 95% of 16-bit max
///     saturation_search_radius: 3.0,    // Check 3px radius for saturation
///     minimum_edge_distance: 40.0,      // 40px from edges
///     bad_pixel_map: BadPixelMap::empty(),
///     minimum_bad_pixel_distance: 5.0,  // 5px from bad pixels
/// }
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GuideStarFilters {
    /// Detection threshold in standard deviations above background noise.
    ///
    /// Stars with peak signal exceeding `background + threshold * noise` are detected.
    /// Lower values find fainter stars but increase false positives from noise.
    /// Typical range: 3.0-7.0 sigma.
    pub detection_threshold_sigma: f64,

    /// Minimum signal-to-noise ratio for guide star selection.
    ///
    /// SNR is computed as `flux / sqrt(flux + background * area)`. Higher SNR stars
    /// provide more precise centroids but may be rare in sparse fields. Stars below
    /// this threshold are rejected during acquisition. Typical range: 5.0-20.0.
    pub snr_min: f64,

    /// Acceptable star diameter range in pixels as (min, max).
    ///
    /// Stars outside this range are rejected. The minimum filters out hot pixels
    /// and cosmic ray hits; the maximum filters out extended sources (galaxies)
    /// or severely defocused stars. Set based on expected PSF FWHM.
    pub diameter_range: (f64, f64),

    /// Maximum aspect ratio (major/minor axis) for star selection.
    ///
    /// Circular stars have aspect ratio ~1.0. Higher values indicate elongation
    /// from tracking errors, cosmic rays, or non-stellar objects. Values above
    /// this threshold are rejected. Typical range: 2.0-3.0.
    pub aspect_ratio_max: f64,

    /// Sensor saturation value in digital numbers (DN/ADU).
    ///
    /// Pixels near or above this value indicate saturation, causing centroid
    /// bias. Stars with any pixels above this value (within `saturation_search_radius`)
    /// are rejected. Set to ~95% of sensor full well capacity.
    pub saturation_value: f64,

    /// Radius in pixels to search for saturated pixels around star center.
    ///
    /// A star is rejected if any pixel within this radius exceeds `saturation_value`.
    /// Should be large enough to encompass the PSF core. Typical range: 2.0-5.0.
    pub saturation_search_radius: f64,

    /// Minimum distance from image edges in pixels.
    ///
    /// Stars closer to any edge than this value are rejected. Must be larger than
    /// `roi_size / 2` to ensure the ROI fits within the image. Provides margin for
    /// tracking motion and edge effects. Typical range: 30-50 pixels.
    pub minimum_edge_distance: f64,

    /// Map of known bad (hot/dead/stuck) pixels to avoid.
    ///
    /// Generated by `dark_frame_analysis` tool. Stars near bad pixels produce
    /// biased centroids and should be avoided during guide star selection.
    pub bad_pixel_map: BadPixelMap,

    /// Minimum distance from bad pixels in pixels.
    ///
    /// Stars with any bad pixel within this radius are rejected. Should be at
    /// least as large as the centroiding aperture radius. Typical range: 3.0-10.0.
    pub minimum_bad_pixel_distance: f64,
}

/// Configuration parameters for the Fine Guidance System (FGS).
///
/// Controls all aspects of guide star acquisition, selection, and tracking.
/// These parameters should be tuned based on the optical system (PSF size),
/// sensor characteristics (noise, saturation), and tracking requirements.
///
/// # Acquisition vs Tracking
/// - **Acquisition**: Full-frame images are captured to detect and select guide stars
/// - **Tracking**: Small ROI windows are read out around selected stars for fast updates
///
/// # Example Configuration
/// ```text
/// FgsConfig {
///     acquisition_frames: 5,
///     filters: GuideStarFilters { /* ... */ },
///     roi_size: 64,
///     max_reacquisition_attempts: 5,
///     centroid_radius_multiplier: 3.0,
///     fwhm: 7.0,
///     snr_dropout_threshold: 3.0,
///     roi_h_alignment: 4,
///     roi_v_alignment: 4,
/// }
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FgsConfig {
    /// Number of full-frame images to capture during acquisition phase.
    ///
    /// Multiple frames improve detection reliability by averaging noise. The FGS
    /// analyzes all frames to identify stable guide star candidates. More frames
    /// increase time-to-lock but reduce false detections. Typical range: 3-10.
    pub acquisition_frames: usize,

    /// Guide star filtering criteria applied during acquisition.
    ///
    /// See [`GuideStarFilters`] for detailed documentation of each filter.
    pub filters: GuideStarFilters,

    /// Size of the ROI window in pixels (square).
    ///
    /// After acquisition, small ROI windows are extracted around guide stars for
    /// fast readout. Must be large enough to contain the full PSF with margin for
    /// motion, but small enough for fast frame rates. Should be compatible with
    /// camera hardware constraints (`roi_h_alignment`, `roi_v_alignment`).
    /// Typical range: 32-128 pixels.
    pub roi_size: usize,

    /// Maximum reacquisition attempts before returning to idle state.
    ///
    /// If tracking is lost (SNR dropout), the FGS attempts to reacquire by
    /// switching to full-frame mode. After this many failed attempts, the FGS
    /// goes idle and requires manual restart. Typical range: 3-10.
    pub max_reacquisition_attempts: usize,

    /// Centroid aperture radius as multiple of FWHM.
    ///
    /// The centroiding algorithm uses a circular aperture of radius
    /// `fwhm * centroid_radius_multiplier` pixels. Larger apertures capture more
    /// PSF flux but include more background noise. Typical range: 2.0-5.0.
    pub centroid_radius_multiplier: f64,

    /// Expected PSF full-width at half-maximum in pixels.
    ///
    /// Critical parameter for centroiding accuracy. Should match the actual optical
    /// system PSF size. Used to compute centroiding aperture and for SNR estimation.
    /// Measure from actual star images if unsure. Typical range: 2.0-15.0 pixels.
    pub fwhm: f64,

    /// SNR threshold below which tracking is considered lost.
    ///
    /// If the guide star's measured SNR drops below this value, the FGS transitions
    /// to reacquisition mode. Should be lower than `filters.snr_min` to provide
    /// hysteresis (avoid rapid lock/unlock cycles). Typical range: 2.0-5.0.
    pub snr_dropout_threshold: f64,

    /// Horizontal ROI offset alignment in pixels.
    ///
    /// Some cameras require ROI offsets to be multiples of this value due to
    /// hardware constraints (e.g., MIPI lane alignment). Set to 1 if no alignment
    /// is required. Query from camera with `get_roi_offset_alignment()`.
    #[serde(default = "default_alignment")]
    pub roi_h_alignment: usize,

    /// Vertical ROI offset alignment in pixels.
    ///
    /// Some cameras require ROI offsets to be multiples of this value due to
    /// hardware constraints. Set to 1 if no alignment is required. Query from
    /// camera with `get_roi_offset_alignment()`.
    #[serde(default = "default_alignment")]
    pub roi_v_alignment: usize,

    /// Downsample factor for noise estimation during calibration.
    ///
    /// The noise estimation algorithm (Chen et al. 2015) is computationally expensive
    /// on large images. This factor controls how much to downsample the image before
    /// estimating noise. A value of N means every Nth pixel is sampled in each dimension,
    /// reducing computation by NÂ² while still providing an accurate global noise estimate.
    ///
    /// For a 9576x6388 image (61MP):
    /// - downsample=1: ~11 seconds (full resolution)
    /// - downsample=8: ~170ms
    /// - downsample=16: ~40ms
    ///
    /// Since noise is a global sensor property, downsampling has minimal impact on
    /// accuracy. Typical range: 8-32.
    #[serde(default = "default_noise_downsample")]
    pub noise_estimation_downsample: usize,
}

fn default_alignment() -> usize {
    1
}

fn default_noise_downsample() -> usize {
    16
}

/// Round a value to the nearest multiple of alignment.
///
/// This is used to snap ROI offsets to hardware-required alignment boundaries
/// while minimizing the distance from the ideal position.
///
/// # Examples
/// - `round_to_nearest_aligned(478, 16)` -> 480 (478 is closer to 480 than 464)
/// - `round_to_nearest_aligned(468, 16)` -> 464 (468 is closer to 464 than 480)
/// - `round_to_nearest_aligned(472, 16)` -> 480 (tie-breaker: rounds up)
fn round_to_nearest_aligned(value: usize, alignment: usize) -> usize {
    if alignment == 0 {
        return value;
    }
    ((value + alignment / 2) / alignment) * alignment
}

impl FgsConfig {
    /// Compute an aligned ROI bounding box centered as close as possible to the given position.
    ///
    /// The ROI offset is snapped to alignment boundaries (roi_h_alignment, roi_v_alignment)
    /// while keeping the star as centered as possible within the ROI.
    ///
    /// # Arguments
    /// * `center_x` - Ideal horizontal center position (column)
    /// * `center_y` - Ideal vertical center position (row)
    /// * `image_width` - Image width for boundary checking
    /// * `image_height` - Image height for boundary checking
    ///
    /// # Returns
    /// An AABB with aligned offsets, or None if the ROI would exceed image bounds
    pub fn compute_aligned_roi(
        &self,
        center_x: f64,
        center_y: f64,
        image_width: usize,
        image_height: usize,
    ) -> Option<AABB> {
        let roi_half = self.roi_size / 2;

        // Compute ideal (unaligned) top-left corner
        let ideal_min_col = (center_x.round() as usize).saturating_sub(roi_half);
        let ideal_min_row = (center_y.round() as usize).saturating_sub(roi_half);

        // Snap to NEAREST alignment boundary (not just round down)
        // This minimizes the offset of the star from the ROI center
        let aligned_min_col = round_to_nearest_aligned(ideal_min_col, self.roi_h_alignment);
        let aligned_min_row = round_to_nearest_aligned(ideal_min_row, self.roi_v_alignment);

        // Compute max corners
        let max_col = aligned_min_col + self.roi_size - 1;
        let max_row = aligned_min_row + self.roi_size - 1;

        // Boundary check
        if max_col >= image_width || max_row >= image_height {
            log::warn!(
                "Aligned ROI ({aligned_min_col}, {aligned_min_row}) to ({max_col}, {max_row}) exceeds image bounds {image_width}x{image_height}"
            );
            return None;
        }

        log::debug!(
            "ROI alignment: ideal center ({:.1}, {:.1}) -> aligned offset ({}, {}), star offset in ROI: ({:.1}, {:.1})",
            center_x,
            center_y,
            aligned_min_col,
            aligned_min_row,
            center_x - aligned_min_col as f64,
            center_y - aligned_min_row as f64
        );

        Some(AABB::from_coords(
            aligned_min_row,
            aligned_min_col,
            max_row,
            max_col,
        ))
    }

    /// Validate configuration parameters
    ///
    /// Checks that configuration values are internally consistent, particularly
    /// that minimum_edge_distance is large enough to accommodate the roi_size.
    /// If a camera is provided, also validates ROI size against camera-specific
    /// hardware constraints.
    ///
    /// # Arguments
    /// * `camera` - Optional camera reference to check hardware-specific ROI constraints
    ///
    /// # Returns
    /// * `Ok(())` if configuration is valid
    /// * `Err(String)` with details if configuration is invalid
    pub fn validate(
        &self,
        camera: Option<&dyn shared::camera_interface::CameraInterface>,
    ) -> Result<(), String> {
        let roi_half = self.roi_size as f64 / 2.0;

        if self.filters.minimum_edge_distance <= roi_half {
            return Err(format!(
                "minimum_edge_distance ({:.1}) must be greater than roi_size/2 ({:.1}) to ensure ROI never extends beyond image boundaries",
                self.filters.minimum_edge_distance,
                roi_half
            ));
        }

        if self.roi_size == 0 {
            return Err("roi_size must be greater than 0".to_string());
        }

        if self.acquisition_frames == 0 {
            return Err("acquisition_frames must be greater than 0".to_string());
        }

        // Validate against camera-specific ROI constraints if camera provided
        if let Some(cam) = camera {
            cam.check_roi_size(shared::image_size::PixelShape::with_width_height(
                self.roi_size,
                self.roi_size,
            ))
            .map_err(|e| format!("ROI size validation failed: {e}"))?;
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_round_to_nearest_aligned_exact_multiple() {
        // Values that are already aligned should stay the same
        assert_eq!(round_to_nearest_aligned(0, 16), 0);
        assert_eq!(round_to_nearest_aligned(16, 16), 16);
        assert_eq!(round_to_nearest_aligned(32, 16), 32);
        assert_eq!(round_to_nearest_aligned(480, 16), 480);
    }

    #[test]
    fn test_round_to_nearest_aligned_rounds_down() {
        // Values closer to the lower boundary should round down
        assert_eq!(round_to_nearest_aligned(1, 16), 0);
        assert_eq!(round_to_nearest_aligned(7, 16), 0);
        assert_eq!(round_to_nearest_aligned(468, 16), 464); // 468 is 4 away from 464, 12 away from 480
        assert_eq!(round_to_nearest_aligned(471, 16), 464); // 471 is 7 away from 464, 9 away from 480
    }

    #[test]
    fn test_round_to_nearest_aligned_rounds_up() {
        // Values closer to the upper boundary should round up
        assert_eq!(round_to_nearest_aligned(9, 16), 16);
        assert_eq!(round_to_nearest_aligned(15, 16), 16);
        assert_eq!(round_to_nearest_aligned(478, 16), 480); // 478 is 14 away from 464, 2 away from 480
        assert_eq!(round_to_nearest_aligned(473, 16), 480); // 473 is 9 away from 464, 7 away from 480
    }

    #[test]
    fn test_round_to_nearest_aligned_tie_rounds_up() {
        // When exactly in the middle, rounds up (standard rounding behavior)
        assert_eq!(round_to_nearest_aligned(8, 16), 16); // exactly halfway
        assert_eq!(round_to_nearest_aligned(472, 16), 480); // exactly halfway between 464 and 480
    }

    #[test]
    fn test_round_to_nearest_aligned_small_alignment() {
        // Test with alignment of 2 (typical vertical alignment)
        assert_eq!(round_to_nearest_aligned(0, 2), 0);
        assert_eq!(round_to_nearest_aligned(1, 2), 2); // rounds up at tie
        assert_eq!(round_to_nearest_aligned(2, 2), 2);
        assert_eq!(round_to_nearest_aligned(3, 2), 4);
        assert_eq!(round_to_nearest_aligned(100, 2), 100);
        assert_eq!(round_to_nearest_aligned(101, 2), 102);
    }

    #[test]
    fn test_round_to_nearest_aligned_alignment_1() {
        // Alignment of 1 should return the value unchanged
        assert_eq!(round_to_nearest_aligned(0, 1), 0);
        assert_eq!(round_to_nearest_aligned(1, 1), 1);
        assert_eq!(round_to_nearest_aligned(478, 1), 478);
    }

    #[test]
    fn test_round_to_nearest_aligned_alignment_0() {
        // Alignment of 0 should return the value unchanged (edge case protection)
        assert_eq!(round_to_nearest_aligned(478, 0), 478);
    }

    #[test]
    fn test_round_to_nearest_aligned_large_values() {
        // Test with realistic image coordinates
        assert_eq!(round_to_nearest_aligned(4784, 16), 4784); // already aligned
        assert_eq!(round_to_nearest_aligned(4785, 16), 4784); // rounds down
        assert_eq!(round_to_nearest_aligned(4791, 16), 4784); // rounds down
        assert_eq!(round_to_nearest_aligned(4792, 16), 4800); // tie rounds up
        assert_eq!(round_to_nearest_aligned(4795, 16), 4800); // rounds up
    }
}
